import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

import java.time.Duration;
import java.util.*;
import java.util.List;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.*;

public class PMO_Test {
    //////////////////////////////////////////////////////////////////////////
    private static final Map<String, Double> tariff = new HashMap<>();

    static {
        tariff.put("alternativesF", 0.3 );
        tariff.put("alternativesE_L", 0.1 );
        tariff.put("alternativesE_R", 0.1 );
        tariff.put("alternativesF_L", 0.1 );
        tariff.put("alternativesF_R", 0.1 );
        tariff.put("alternativesS_L", 0.1 );
        tariff.put("alternativesS_R", 0.1 );
        tariff.put("noAlternativesE", 0.6);
        tariff.put("noAlternativesF", 0.6);
        tariff.put("noAlternativesS", 0.6 );
        tariff.put("simplestE", 1.0 );
        tariff.put("simplestF", 1.0 );
        tariff.put("simplestS", 1.0 );
    }

    public static double getTariff(String testName) {
        return tariff.get(testName);
    }

    //////////////////////////////////////////////////////////////////////////

    private PathFinderInterface pathFinder;

    private int[][] map;
    private List<String> mapGenerator = new LinkedList<>();
    private List<String> solution = new ArrayList<>();
    private int cols;
    private int rows;
    private PositionInterface start;
    private PositionInterface stop;
    private Position lastVisited;
    private Random rnd = new Random();

    private class Position implements  PositionInterface {
        private final int col;
        private final int row;

        Position( int col, int row ) {
            this.col = col;
            this.row = row;
        }

        Position( PositionInterface pi ) {
            this.col = pi.getCol();
            this.row = pi.getRow();
        }

        @Override
        public int getRow() {
            return row;
        }

        @Override
        public int getCol() {
            return col;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Position position = (Position) o;
            return col == position.col &&
                    row == position.row;
        }

        @Override
        public int hashCode() {
            return Objects.hash(col, row);
        }

        @Override
        public String toString() {
            return "Position{" +
                    "col=" + col +
                    ", row=" + row +
                    '}';
        }
    }

    private void add( List<String> list, String row ) {
        if ( list.isEmpty() ) cols = row.length();

assert row.length() == cols : "Błąd: zła długość ciągu wysłanego do add";

        list.add( row );
    }

    private void add( String row ) {
        add( mapGenerator, row );
    }

    private void addS( String row ) {
        add( solution, row );
    }

    private int char2int( char ch ) {

        switch ( ch ) {
            case 'S' : return 1;
            case 'F' : return 1;
            case '*' : return 0;
        }

        return ch - '0';
    }

    private void fillOneRow( String row, int rowIx ) {
        IntStream.range(0,cols).forEach( i -> map[i][rowIx] = char2int( row.charAt( i ) ) );
    }

    private void analyzePosition( int i ) {
        int col =  i % cols;
        int row = i / cols;

        if ( mapGenerator.get(row).charAt(col) == 'F' ) {
            stop = new Position( col, row );
        }
        if ( mapGenerator.get(row).charAt(col) == 'S' ) {
            start = new Position( col, row );
        }
    }

    private void findStartStop() {
        IntStream.range(0,mapGenerator.size() * cols).forEach( i -> analyzePosition(i));

assert start != null && stop != null : "Wewnętrzny błąd testu: Brak pozycji początkowej i końcowej";
    }

    private void generate() {
        rows = mapGenerator.size();
        map = new int[ cols ][ rows ];

        IntStream.range(0,mapGenerator.size()).forEach( rIx -> fillOneRow( mapGenerator.get(rIx), rIx ));
    }

    private void prepare() {
        Collections.reverse( mapGenerator );
        findStartStop();
        generate();

        try {
            pathFinder.setMap( map );
        } catch ( Exception e ) {
            showException( e, "setMAP");
        }
    }

    private List<Position> getPositions(Supplier<PositionInterface[]> dostawca, String opis ) {
        PositionInterface[] solution = null;
        try {
            solution =
            assertTimeoutPreemptively( Duration.ofMillis( 1000 ), () -> {
                return dostawca.get();
            });
        } catch ( Exception e ) {
            showException( e, opis );
        }

        assertNotNull( solution, "Rowiązaniem nie może byc null" );
        assertFalse( Arrays.stream( solution).anyMatch( s -> s == null ), "W tablicy będącej rozwiązaniem wykryto null" );

        return Arrays.stream( solution ).map( Position::new ).collect( Collectors.toList() );
    }

    private static void showException(Exception e, String txt) {
        e.printStackTrace();
        fail("W trakcie pracy metody " + txt + " doszło do wyjątku " + e.toString());
    }

    private char getCharAtSolution( Position position ) {

        assertTrue( position.col > 0 && position.col < cols, "Kolumna poza mapą " + position );
        assertTrue( position.row > 0 && position.row < rows, "Wiersz poza mapą " + position );

        return solution.get(position.row).charAt( position.col);
    }

    private int distance( Position p1, Position p2 ) {
        return Math.abs( p1.col - p2.col ) + Math.abs( p1.row - p2.row );
    }

    private void testResult( Position position ) {
        assertEquals( '#', getCharAtSolution( position ), "Pozycja poza oczekiwaną trasą " + position );

        assertEquals( 1, distance( lastVisited, position ), "Błędna odległość pomiędzy kolejnymi pozycjami trasy");

        lastVisited = position;
    }

    private void testResult(List<Position> result) {
        try {

            Collections.reverse( solution );

            assertTrue( result.size() > 2, "Oczekiwano, że rozwiązanie będzie zawierać co najmniej 2 pozycje");
            assertEquals( 'S', getCharAtSolution( result.get(0)), "Pierwsza pozycja rozwiązania to ani begin ani end" );
            assertEquals( 'S', getCharAtSolution( result.get( result.size()-1)), "Ostatnia pozycja rozwiązania to ani begin ani end");

            lastVisited = result.get(0);

            IntStream.range(1,result.size()-1).mapToObj( idx -> result.get(idx) ).forEach( p -> testResult( p ) );
        } catch ( Exception e ) {
            showException( e, "Niezpodziewany błąd w testResult");
        }
    }

    private void showMap() {
        for ( int row = rows-1; row >= 0; row--) {
            System.out.printf( "%02d ", row );
            for ( int col = 0; col < cols; col++) {
                System.out.print( map[ col ][ row ] + " " );
            }
            System.out.println();
        }
    }

    @BeforeEach
    public void create() {
        mapGenerator.clear();
        solution.clear();
    }

    static Stream<Arguments> directions() {
        return Stream.of(
                Arguments.of( PathFinderEnum.LEFT_HAND_TRAFFIC, "LEFT_HAND_TRAFFIC"),
                Arguments.of( PathFinderEnum.RIGHT_HAND_TRAFFIC, "RIGHT_HAND_TRAFFICs")
        );
    }
    
    @ParameterizedTest
    @DisplayName("Brak alternatyw, brak ślepych ulic - trasa najkrótsza")
    @MethodSource( "directions")
    public void simplestS(PathFinderInterface pathFinder, String description ) {

        this.pathFinder = pathFinder;

        add("******************");
        add("*****3444****211F*");
        add("*****3**1****2****");
        add("*****3**1****2****");
        add("*****3**111111****");
        add("*111*3************");
        add("*S*222************");
        add("******************");

        prepare();

        List<Position> result =
                getPositions( () -> pathFinder.getShortestRoute(start,stop),  description + " getShortestRoute");

        addS("******************");
        addS("*****####****###S*");
        addS("*****#**#****#****");
        addS("*****#**#****#****");
        addS("*****#**######****");
        addS("*###*#************");
        addS("*S*###************");
        addS("******************");

        testResult( result );
    }

    @ParameterizedTest
    @DisplayName("Brak alternatyw, brak ślepych ulic - trasa najłatfiejsza")
    @MethodSource( "directions")
    public void simplestE(PathFinderInterface pathFinder, String description ) {

        this.pathFinder = pathFinder;

        add("******************");
        add("*****3444****211F*");
        add("*****3**1****2****");
        add("*****3**1****2****");
        add("*****3**111111****");
        add("*111*3************");
        add("*S*222************");
        add("******************");

        prepare();

        List<Position> result =
                getPositions( () -> pathFinder.getEasiestRoute(start,stop), description + " getEasiestRoute");

        addS("******************");
        addS("*****####****###S*");
        addS("*****#**#****#****");
        addS("*****#**#****#****");
        addS("*****#**######****");
        addS("*###*#************");
        addS("*S*###************");
        addS("******************");

        testResult( result );
    }

    @ParameterizedTest
    @DisplayName("Brak alternatyw, brak ślepych ulic - trasa najszybsza")
    @MethodSource( "directions")
    public void simplestF(PathFinderInterface pathFinder, String description ) {

        this.pathFinder = pathFinder;

        add("******************");
        add("*****3444****211F*");
        add("*****3**1****2****");
        add("*****3**1****2****");
        add("*****3**111111****");
        add("*111*3************");
        add("*S*222************");
        add("******************");

        prepare();

        List<Position> result =
                getPositions( () -> pathFinder.getFastestRoute(start,stop), description + " getFastestRoute");

        addS("******************");
        addS("*****####****###S*");
        addS("*****#**#****#****");
        addS("*****#**#****#****");
        addS("*****#**######****");
        addS("*###*#************");
        addS("*S*###************");
        addS("******************");

        testResult( result );
    }

    @ParameterizedTest
    @DisplayName("Brak alternatyw - Fastest")
    @MethodSource( "directions")
    public void noAlternativesF(PathFinderInterface pathFinder, String description ) {

        this.pathFinder = pathFinder;

        add("************************************************************************************");
        add("********************************44442426474756766575858586865***********************");
        add("***16354523234424232341116*********************2********3*******4*******************");
        add("***1*********************6********************777*******5****6666666666666666*******");
        add("***1***113455555623111***5******************666*888*****5*******1*********6*********");
        add("***1***1*************1***4141141241*******555*****111***2222****1*********5*********");
        add("***1***11131311321***1***3******1*******444*********222*********1*********77777F****");
        add("***1*************1***1***31323**1*****114*************444*******1*******************");
        add("*****************1***11111******1*****1*****************555*****1*******************");
        add("*11123421231131311**************4444444*******************666**11111****************");
        add("*S**********************************************************7777********************");
        add("************************************************************************************");

        prepare();

        List<Position> result =
                getPositions( () -> pathFinder.getFastestRoute( start, stop ), description );

        addS("************************************************************************************");
        addS("********************************44442426474756766575858586865***********************");
        addS("***16354523234424232341116*********************2********3*******4*******************");
        addS("***1*********************6********************###*******5****666###########66*******");
        addS("***1***###############***5******************###*###*****5*******#*********#*********");
        addS("***1***#*************#***########41*******###*****###***2222****#*********#*********");
        addS("***1***###########***#***#******#*******###*********###*********#*********#####S****");
        addS("***1*************#***#***#1323**#*****###*************###*******#*******************");
        addS("*****************#***#####******#*****#*****************###*****#*******************");
        addS("*#################**************#######*******************###**##111****************");
        addS("*S**********************************************************####********************");
        addS("************************************************************************************");

        testResult( result );
    }

    @ParameterizedTest
    @DisplayName("Brak alternatyw - Easiest")
    @MethodSource( "directions")
    public void noAlternativesE(PathFinderInterface pathFinder, String description ) {

        this.pathFinder = pathFinder;

        add("************************************************************************************");
        add("********************************44442426474756766575858586865***********************");
        add("***16354523234424232341116*********************2********3*******4*******************");
        add("***1*********************6********************777*******5****6666666666666666*******");
        add("***1***113455555623111***5******************666*888*****5*******1*********6*********");
        add("***1***1*************1***4141141241*******555*****111***2222****1*********5*********");
        add("***1***11131311321***1***3******1*******444*********222*********1*********77777F****");
        add("***1*************1***1***31323**1*****114*************444*******1*******************");
        add("*****************1***11111******1*****1*****************555*****1*******************");
        add("*11123421231131311**************4444444*******************666**11111****************");
        add("*S**********************************************************7777********************");
        add("************************************************************************************");

        prepare();

        List<Position> result =
                getPositions( () -> pathFinder.getEasiestRoute( start, stop ), description );

        addS("************************************************************************************");
        addS("********************************44442426474756766575858586865***********************");
        addS("***16354523234424232341116*********************2********3*******4*******************");
        addS("***1*********************6********************###*******5****666###########66*******");
        addS("***1***###############***5******************###*###*****5*******#*********#*********");
        addS("***1***#*************#***########41*******###*****###***2222****#*********#*********");
        addS("***1***###########***#***#******#*******###*********###*********#*********#####S****");
        addS("***1*************#***#***#1323**#*****###*************###*******#*******************");
        addS("*****************#***#####******#*****#*****************###*****#*******************");
        addS("*#################**************#######*******************###**##111****************");
        addS("*S**********************************************************####********************");
        addS("************************************************************************************");

        testResult( result );
    }

    @ParameterizedTest
    @DisplayName("Brak alternatyw - Shortest")
    @MethodSource( "directions")
    public void noAlternativesS(PathFinderInterface pathFinder, String description ) {

        this.pathFinder = pathFinder;

        add("************************************************************************************");
        add("********************************44442426474756766575858586865***********************");
        add("***16354523234424232341116*********************2********3*******4*******************");
        add("***1*********************6********************777*******5****6666666666666666*******");
        add("***1***113455555623111***5******************666*888*****5*******1*********6*********");
        add("***1***1*************1***4141141241*******555*****111***2222****1*********5*********");
        add("***1***11131311321***1***3******1*******444*********222*********1*********77777S****");
        add("***1*************1***1***31323**1*****114*************444*******1*******************");
        add("*****************1***11111******1*****1*****************555*****1*******************");
        add("*11123421231131311**************4444444*******************666**11111****************");
        add("*F**********************************************************7777********************");
        add("************************************************************************************");

        prepare();

        List<Position> result =
                getPositions( () -> pathFinder.getShortestRoute( start, stop ), description );

        addS("************************************************************************************");
        addS("********************************44442426474756766575858586865***********************");
        addS("***16354523234424232341116*********************2********3*******4*******************");
        addS("***1*********************6********************###*******5****666###########66*******");
        addS("***1***###############***5******************###*###*****5*******#*********#*********");
        addS("***1***#*************#***########41*******###*****###***2222****#*********#*********");
        addS("***1***###########***#***#******#*******###*********###*********#*********#####S****");
        addS("***1*************#***#***#1323**#*****###*************###*******#*******************");
        addS("*****************#***#####******#*****#*****************###*****#*******************");
        addS("*#################**************#######*******************###**##111****************");
        addS("*S**********************************************************####********************");
        addS("************************************************************************************");

        testResult( result );
    }

    ////////////////////////////////////////////////////////////////////////////////////////

    @ParameterizedTest
    @DisplayName("Są alternatywy - Fastest")
    @MethodSource( "directions")
    public void alternativesF(PathFinderInterface pathFinder, String description ) {

        this.pathFinder = pathFinder;

        add("************************************************************************************");
        add("*112****************************11111***********************************************");
        add("*1*1*121111111111111111111112***1***122222222222222222222222222222222222222222222***");
        add("*1*2*2**********************2***1***1*******************************************2***");
        add("*1*1*2**********************1***19991*******************************************F***");
        add("*1*1*1***21111111111111111111***1***1*******************************************1***");
        add("*1*1*1***1**********************1***111111111111111111111111111111111111111111111***");
        add("*1*1*1***2**********************1***********************************************1***");
        add("*1*112***111111111111111111111111*************************************99289912111***");
        add("*1********************************************************************1*************");
        add("*S122111899989779879797979797979797987979797979797979797979797979798888*************");
        add("************************************************************************************");
        add("************************************************************************************");

        prepare();

        List<Position> result =
                getPositions( () -> pathFinder.getFastestRoute( start, stop ), description + " Fastest");

        addS("************************************************************************************");
        addS("*###****************************#####***********************************************");
        addS("*#*#*########################***#***#***********************************************");
        addS("*#*#*#**********************#***#***#***********************************************");
        addS("*#*#*#**********************#***#***#*******************************************S***");
        addS("*#*#*#***####################***#***#*******************************************#***");
        addS("*#*#*#***#**********************#***#############################################***");
        addS("*#*#*#***#**********************#***************************************************");
        addS("*#*###***########################***************************************************");
        addS("*#**********************************************************************************");
        addS("*S**********************************************************************************");
        addS("************************************************************************************");
        addS("************************************************************************************");

        testResult( result );
    }
  
    @Test
    @DisplayName("Są alternatywy - Shortest - LEFT")
    public void alternativesS_L() {

        this.pathFinder = PathFinderEnum.LEFT_HAND_TRAFFIC;

        add("************************************************************************************");
        add("************111111111***************************************************************");
        add("************1*******1***************************************************************");
        add("****111111111*******1111111*********************************************************");
        add("****1*******1*******1*****1*********************************************************");
        add("****1*******111111111*****1*********************************************************");
        add("*S111*********************11111111111111111111111111F*******************************");
        add("****1*********************1*********************************************************");
        add("****1*******222222222*****1*********************************************************");
        add("****111111111*******1111111*********************************************************");
        add("************222222222***************************************************************");
        add("************************************************************************************");

        prepare();

        List<Position> result =
                getPositions( () -> pathFinder.getShortestRoute( start, stop ), "LEFT + Shortest");

        addS("************************************************************************************");
        addS("************************************************************************************");
        addS("************************************************************************************");
        addS("************************************************************************************");
        addS("************************************************************************************");
        addS("************************************************************************************");
        addS("*S###*********************##########################S*******************************");
        addS("****#*********************#*********************************************************");
        addS("****#*******#########*****#*********************************************************");
        addS("****#########*******#######*********************************************************");
        addS("************************************************************************************");
        addS("************************************************************************************");

        testResult( result );
    }
    
    @Test
    @DisplayName("Są alternatywy - Shortest - RIGHT")
    public void alternativesS_R() {

        this.pathFinder = PathFinderEnum.RIGHT_HAND_TRAFFIC;

        add("************************************************************************************");
        add("************111111111***************************************************************");
        add("************1*******1***************************************************************");
        add("****111111111*******1111111*********************************************************");
        add("****1*******1*******1*****1*********************************************************");
        add("****1*******111111111*****1*********************************************************");
        add("*S111*********************11111111111111111111111111F*******************************");
        add("****1*********************1*********************************************************");
        add("****1*******222222222*****1*********************************************************");
        add("****111111111*******1111111*********************************************************");
        add("************222222222***************************************************************");
        add("************************************************************************************");

        prepare();

        List<Position> result =
                getPositions( () -> pathFinder.getShortestRoute( start, stop ), "RIGHT + Fastest");

        addS("************************************************************************************");
        addS("************************************************************************************");
        addS("************************************************************************************");
        addS("************************************************************************************");
        addS("************************************************************************************");
        addS("************************************************************************************");
        addS("*S###*********************##########################S*******************************");
        addS("****#*********************#*********************************************************");
        addS("****#*********************#*********************************************************");
        addS("****#########*******#######*********************************************************");
        addS("************#########***************************************************************");
        addS("************************************************************************************");

        testResult( result );
    }
    
    @Test
    @DisplayName("Są alternatywy - Fastest - LEFT")
    public void alternativesF_L() {

        this.pathFinder = PathFinderEnum.LEFT_HAND_TRAFFIC;

        add("************************************************************************************");
        add("************111111111***************************************************************");
        add("************1*******1***************************************************************");
        add("****111111111*******1111111*********************************************************");
        add("****1*******1*******1*****1*********************************************************");
        add("****1*******111111111*****1*********************************************************");
        add("*S111*********************11111111111111111111111111F*******************************");
        add("****1*********************1*********************************************************");
        add("****1*******222222222*****1*********************************************************");
        add("****111111111*******1111111*********************************************************");
        add("************222222222***************************************************************");
        add("************************************************************************************");

        prepare();

        List<Position> result =
                getPositions( () -> pathFinder.getFastestRoute( start, stop ), "LEFT + Fastest");

        addS("************************************************************************************");
        addS("************#########***************************************************************");
        addS("************#*******#***************************************************************");
        addS("****#########*******#######*********************************************************");
        addS("****#*********************#*********************************************************");
        addS("****#*********************#*********************************************************");
        addS("*S###*********************##########################S*******************************");
        addS("************************************************************************************");
        addS("************************************************************************************");
        addS("************************************************************************************");
        addS("************************************************************************************");
        addS("************************************************************************************");

        testResult( result );
    }
    
    @Test
    @DisplayName("Są alternatywy - Fastest - RIGHT")
    public void alternativesF_R() {

        this.pathFinder = PathFinderEnum.RIGHT_HAND_TRAFFIC;

        add("************************************************************************************");
        add("************111111111***************************************************************");
        add("************1*******1***************************************************************");
        add("****11111111144444441111111*********************************************************");
        add("****1*******1*******1*****1*********************************************************");
        add("****1*******111111111*****1*********************************************************");
        add("*S111*********************11111111111111111111111111F*******************************");
        add("****1*********************1*********************************************************");
        add("****1*******222222222*****1*********************************************************");
        add("****111111111*******1111111*********************************************************");
        add("************222222222***************************************************************");
        add("************************************************************************************");

        prepare();

        List<Position> result =
                getPositions( () -> pathFinder.getFastestRoute( start, stop ), "RIGHT + Fastest");

        addS("************************************************************************************");
        addS("************************************************************************************");
        addS("************************************************************************************");
        addS("****#########*******#######*********************************************************");
        addS("****#*******#*******#*****#*********************************************************");
        addS("****#*******#########*****#*********************************************************");
        addS("*S###*********************##########################S*******************************");
        addS("************************************************************************************");
        addS("************************************************************************************");
        addS("************************************************************************************");
        addS("************************************************************************************");
        addS("************************************************************************************");

        testResult( result );
    }
    
    @Test
    @DisplayName("Są alternatywy - Easiest - RIGHT")
    public void alternativesE_R() {

        this.pathFinder = PathFinderEnum.RIGHT_HAND_TRAFFIC;

        add("************************************************************************************");
        add("**1111111111111111*****111111***1******11111111111111111111*************************");
        add("**1**************1111111****1***1******1***********1*********11111111111111111111***");
        add("**111111111111*********1****11111******1***********1****111111******************1***");
        add("**********1************1****1***11111111111********111111*******88454341414141444F**");
        add("**********1111111111***1****1**********************1****1*******4*******************");
        add("***************1*******1****1***************11111111************3*******************");
        add("**S1111111111111*******1****11111111111111**************345566661*******************");
        add("*****1************111111*****************1**2314424134111***************************");
        add("*****9999999*************11111111111111111**1***************************************");
        add("***********676687868788*********************1***************************************");
        add("**********************11298238989389389238923***************************************");
        add("************************************************************************************");
        add("************************************************************************************");

        prepare();

        List<Position> result =
                getPositions( () -> pathFinder.getEasiestRoute( start, stop ), "RIGHT + Easiest");

        addS("************************************************************************************");
        addS("************************************************************************************");
        addS("************************************************************************************");
        addS("************************************************************************************");
        addS("****************************************************************#################S**");
        addS("****************************************************************#*******************");
        addS("****************************************************************#*******************");
        addS("**S###**************************************************#########*******************");
        addS("*****#**************************************#############***************************");
        addS("*****#######********************************#***************************************");
        addS("***********############*********************#***************************************");
        addS("**********************#######################***************************************");
        addS("************************************************************************************");
        addS("************************************************************************************");

        testResult( result );
    }

    @Test
    @DisplayName("Są alternatywy - Easiest - LEFT")
    public void alternativesE_L() {

        this.pathFinder = PathFinderEnum.LEFT_HAND_TRAFFIC;

        add("************************************************************************************");
        add("**1111111111111111*****111111***1******11111111111111111111*************************");
        add("**1**************1111111****1***1******1***********1*********11111111111111111111***");
        add("**111111111111*********1****11111******1***********1****111111******************1***");
        add("**********1************1****1***11111111111********111111*******88454341414141444F**");
        add("**********1111111111***1****1**********************1****1*******4*******************");
        add("***************1*******1****1***************11111111************3*******************");
        add("**S1111111111111*******1****11111111111111**************345566661*******************");
        add("*****1************111111*****************1**2314424134111***************************");
        add("*****9999999*************11111111111111111**1***************************************");
        add("***********676687868788*********************1***************************************");
        add("**********************11298238989389389238923***************************************");
        add("************************************************************************************");
        add("************************************************************************************");

        Collections.reverse( mapGenerator );

        prepare();

        List<Position> result =
                getPositions( () -> pathFinder.getEasiestRoute( start, stop ), "LEFT + Easiest");

        addS("************************************************************************************");
        addS("************************************************************************************");
        addS("************************************************************************************");
        addS("************************************************************************************");
        addS("****************************************************************#################S**");
        addS("****************************************************************#*******************");
        addS("****************************************************************#*******************");
        addS("**S###**************************************************#########*******************");
        addS("*****#**************************************#############***************************");
        addS("*****#######********************************#***************************************");
        addS("***********############*********************#***************************************");
        addS("**********************#######################***************************************");
        addS("************************************************************************************");
        addS("************************************************************************************");

        Collections.reverse( solution );

        testResult( result );
    }

}

